<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ION - 1.1 Omni Robot Controller</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      background: #f5f7fa;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    header {
      background: linear-gradient(to right, #2c3e50, #3498db);
      color: white;
      width: 100%;
      padding: 20px 0;
      text-align: center;
      font-size: 2rem;
      font-weight: bold;
    }
    .controller {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 40px;
      padding: 30px 10px 0;
    }
    .joystick-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .joystick-container label {
      font-weight: 600;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .joystick-output, .wheel-output {
      margin-top: 8px;
      font-size: 14px;
      font-family: monospace;
      background: #fff;
      border: 1px solid #ccc;
      padding: 6px 12px;
      border-radius: 6px;
    }
    canvas {
      background: white;
      border: 2px solid #333;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    #dirJoystick {
      border-radius: 50%;
    }
    .slider-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 30px;
      gap: 20px;
    }
    .slider-container {
      background: #ffffff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.1);
    }
    .slider-container h3 {
      margin-top: 0;
      font-size: 1.2rem;
      border-bottom: 1px solid #ccc;
      padding-bottom: 6px;
    }
    .slider-group {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
      gap: 10px;
    }
    .slider-group label {
      flex: 1;
      font-weight: 600;
    }
    .slider-group input[type="range"] {
      flex: 2;
      accent-color: #007bff;
    }
    .slider-value {
      width: 60px;
      text-align: right;
      font-family: monospace;
    }
    @media (max-width: 768px) {
      .controller, .slider-section {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
</head>
<body>
  <header>ION - 1.1 — Omni Robot Controller — SumukhArood</header>

  <div class="controller">
    <div class="joystick-container">
      <label>Direction Control</label>
      <canvas id="dirJoystick" width="150" height="150"></canvas>
      <div class="joystick-output" id="vxvyDisplay">Vx: 0.00<br>Vy: 0.00</div>
    </div>
    <div class="joystick-container">
      <label>Navigation Map</label>
      <canvas id="robotCanvas" width="200" height="200"></canvas>
    </div>
    <div class="joystick-container">
      <label>Rotation Control</label>
      <canvas id="rotJoystick" width="150" height="50"></canvas>
      <div class="joystick-output" id="wzDisplay">Wz: 0.00</div>
      <div class="wheel-output" id="wheelOutput">W1: 0.00<br>W2: 0.00<br>W3: 0.00</div>
    </div>
  </div>

  <div class="slider-section">
    <div class="slider-container">
      <h3>Tuning</h3>
      <div class="slider-group">
        <label>Speed Control</label>
        <input type="range" id="speed" min="100" max="1000" value="550">
        <span id="speedVal" class="slider-value">550</span>
      </div>
      <div class="slider-group">
        <label>Rotation Gain</label>
        <input type="range" id="rotationGain" min="0" max="1" step="0.01" value="0.3">
        <span id="rotationVal" class="slider-value">0.30</span>
      </div>
      <div class="slider-group">
        <label>Radius R (cm)</label>
        <input type="range" id="radius" min="5" max="20" step="0.1" value="9.0">
        <span id="radiusVal" class="slider-value">9.0</span>
      </div>
    </div>
  </div>

<script>
let Vx = 0, Vy = 0, Wz = 0;
let maxSpeed = 550;
let ROTATION_GAIN = 0.3;
let R = 9.0;
let W1 = 0, W2 = 0, W3 = 0;

// Direction Joystick
const dirCanvas = document.getElementById('dirJoystick');
const dirCtx = dirCanvas.getContext('2d');
const dirCenter = { x: 75, y: 75, radius: 60 };
let dirStick = { x: 75, y: 75 };

function drawDirJoystick() {
  dirCtx.clearRect(0, 0, 150, 150);
  dirCtx.beginPath();
  dirCtx.arc(dirCenter.x, dirCenter.y, dirCenter.radius, 0, Math.PI * 2);
  dirCtx.stroke();
  dirCtx.beginPath();
  dirCtx.arc(dirStick.x, dirStick.y, 10, 0, Math.PI * 2);
  dirCtx.fillStyle = 'red';
  dirCtx.fill();
}

function handleDirInput(clientX, clientY) {
  const rect = dirCanvas.getBoundingClientRect();
  const x = clientX - rect.left;
  const y = clientY - rect.top;
  let dx = x - dirCenter.x;
  let dy = y - dirCenter.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist > dirCenter.radius) {
    dx *= dirCenter.radius / dist;
    dy *= dirCenter.radius / dist;
  }
  dirStick.x = dirCenter.x + dx;
  dirStick.y = dirCenter.y + dy;
  Vx = -dy / dirCenter.radius;
  Vy = dx / dirCenter.radius;
  drawDirJoystick();
  compute();
}

dirCanvas.addEventListener('mousedown', () => {
  function move(e) {
    handleDirInput(e.clientX, e.clientY);
  }
  document.addEventListener('mousemove', move);
  document.addEventListener('mouseup', () => {
    dirStick = { x: dirCenter.x, y: dirCenter.y };
    Vx = 0; Vy = 0;
    drawDirJoystick(); compute();
    document.removeEventListener('mousemove', move);
  }, { once: true });
});

dirCanvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  function move(ev) {
    const t = ev.touches[0];
    handleDirInput(t.clientX, t.clientY);
  }
  document.addEventListener('touchmove', move);
  document.addEventListener('touchend', () => {
    dirStick = { x: dirCenter.x, y: dirCenter.y };
    Vx = 0; Vy = 0;
    drawDirJoystick(); compute();
    document.removeEventListener('touchmove', move);
  }, { once: true });
}, { passive: false });


// Rotation Joystick
const rotCanvas = document.getElementById('rotJoystick');
const rotCtx = rotCanvas.getContext('2d');
let rotX = 75;

function drawRotJoystick() {
  rotCtx.clearRect(0, 0, 150, 50);
  rotCtx.strokeRect(5, 5, 140, 40);
  rotCtx.beginPath();
  rotCtx.arc(rotX, 25, 8, 0, Math.PI * 2);
  rotCtx.fillStyle = 'red';
  rotCtx.fill();
}

// Shared function for rotation joystick input
function handleRotInput(clientX) {
  const rect = rotCanvas.getBoundingClientRect();
  let x = clientX - rect.left;
  x = Math.max(15, Math.min(x, 135));
  rotX = x;
  Wz = (rotX - 75) / 60;
  drawRotJoystick();
  compute();
}

// Mouse input
rotCanvas.addEventListener('mousedown', () => {
  function move(evt) {
    handleRotInput(evt.clientX);
  }
  document.addEventListener('mousemove', move);
  document.addEventListener('mouseup', () => {
    rotX = 75;
    Wz = 0;
    drawRotJoystick();
    compute();
    document.removeEventListener('mousemove', move);
  }, { once: true });
});

// Touch input (for iPad, phones)
rotCanvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  function move(ev) {
    const t = ev.touches[0];
    handleRotInput(t.clientX);
  }
  document.addEventListener('touchmove', move);
  document.addEventListener('touchend', () => {
    rotX = 75;
    Wz = 0;
    drawRotJoystick();
    compute();
    document.removeEventListener('touchmove', move);
  }, { once: true });
}, { passive: false });


// Sliders
document.getElementById('speed').addEventListener('input', (e) => {
  maxSpeed = parseInt(e.target.value);
  document.getElementById('speedVal').textContent = maxSpeed;
  compute();
});

document.getElementById('rotationGain').addEventListener('input', (e) => {
  ROTATION_GAIN = parseFloat(e.target.value);
  document.getElementById('rotationVal').textContent = ROTATION_GAIN.toFixed(2);
  compute();
});

document.getElementById('radius').addEventListener('input', (e) => {
  R = parseFloat(e.target.value);
  document.getElementById('radiusVal').textContent = R.toFixed(1);
  compute();
});

// Telemetry & Wheel Calculations
function compute() {
  W1 = (-Vx + ROTATION_GAIN * R * Wz) * maxSpeed;
  W2 = (0.5 * Vx + 0.866 * Vy + ROTATION_GAIN * R * Wz) * maxSpeed;
  W3 = (0.5 * Vx - 0.866 * Vy + ROTATION_GAIN * R * Wz) * maxSpeed;

  W1 = Math.max(-500, Math.min(500, W1));
  W2 = Math.max(-500, Math.min(500, W2));
  W3 = Math.max(-500, Math.min(500, W3));

  document.getElementById('vxvyDisplay').innerHTML = `Vx: ${Vx.toFixed(2)}<br>Vy: ${Vy.toFixed(2)}`;
  document.getElementById('wzDisplay').innerHTML = `Wz: ${Wz.toFixed(2)}`;
  document.getElementById('wheelOutput').innerHTML = `W1: ${W1.toFixed(2)}<br>W2: ${W2.toFixed(2)}<br>W3: ${W3.toFixed(2)}`;
}

// Robot Canvas + Wheel Orientation
const robotCanvas = document.getElementById('robotCanvas');
const ctx = robotCanvas.getContext('2d');
let pos = { x: 0, y: 0 };
let angle = 0;

function drawGrid(offsetX, offsetY) {
  const spacing = 20;
  ctx.strokeStyle = "#ccc";
  ctx.lineWidth = 1;
  for (let x = -spacing; x < 200 + spacing; x += spacing) {
    ctx.beginPath();
    ctx.moveTo(x + offsetX % spacing, 0);
    ctx.lineTo(x + offsetX % spacing, 200);
    ctx.stroke();
  }
  for (let y = -spacing; y < 200 + spacing; y += spacing) {
    ctx.beginPath();
    ctx.moveTo(0, y + offsetY % spacing);
    ctx.lineTo(200, y + offsetY % spacing);
    ctx.stroke();
  }
}

function drawHexagon(cx, cy, radius, angleRad) {
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(angleRad);

  // Hex body
  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const theta = i * Math.PI / 3;
    const x = radius * Math.cos(theta);
    const y = radius * Math.sin(theta);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.closePath();
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.fillStyle = "#eee";
  ctx.fill();

  // Draw wheels at top, bottom-left, and bottom-right like your image
const wheelPos = [
  { x: 0, y: -(radius) },                   // Top
  { x: -(radius * Math.cos(Math.PI / 6)), y: radius * Math.sin(Math.PI / 6) },  // Bottom-left
  { x: +(radius * Math.cos(Math.PI / 6)), y: radius * Math.sin(Math.PI / 6) }   // Bottom-right
];

function drawWheel(x, y, angleRad) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angleRad);
  ctx.fillStyle = "#000";
  ctx.beginPath();
  const w = 20, h = 8;
  ctx.roundRect(-w / 2, -h / 2, w, h, 2);
  ctx.fill();
  ctx.restore();
}

const rOffset = radius + 3;
drawWheel(0, -rOffset, 0);  // Top (0°)
drawWheel(rOffset * Math.cos(Math.PI / 6), rOffset * Math.sin(Math.PI / 6), -Math.PI / 3); // Left (-60°)
drawWheel(-rOffset * Math.cos(Math.PI / 6), rOffset * Math.sin(Math.PI / 6), +Math.PI / 3); // Right (+60°)



  // Front red indicator
  ctx.save();
  ctx.rotate(Math.PI / 2);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(radius, -8);
  ctx.lineTo(radius, 8);
  ctx.closePath();
  ctx.fillStyle = "red";
  ctx.fill();
  ctx.restore();
  ctx.restore();
}

function updateAnimation() {
  const dx = Vy * Math.cos(-angle) - Vx * Math.sin(-angle);
  const dy = Vy * Math.sin(-angle) + Vx * Math.cos(-angle);

  pos.x += dx * 2;
  pos.y -= dy * 2;
  angle += Wz * 0.05;

  ctx.clearRect(0, 0, 200, 200);
  drawGrid(-pos.x + 100, -pos.y + 100);
  drawHexagon(100, 100, 30, angle);
  requestAnimationFrame(updateAnimation);
}

drawDirJoystick();
drawRotJoystick();
compute();
updateAnimation();
</script>

</body>
</html>
